&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-21 13:22:59  

# 简介
这里呢, 主要是按照那个日本老哥提供的参考样式来编写的. 其实其它的也都是按照日本老哥的为例子参考, 其它地方就不再多说了. 由于他做的非常完整, 想要内化为自己的, 必须建立个人的理解. 我现在主要分析的是结构问题, 跟代码关系不是那么的大, 所以呢, 主要关心结构, 代码实现细节并不关注. 等完全明白结构后, 再去看细节实现. 

- [理解](#理解)

## 理解
- 抽象工厂, 提供生成产品的接口. 抽象产品, 提供生成产品的接口. 具体产品工厂, 实现抽象工厂, 并且实现抽象产品. 
    - 可拓展点, 就是具体产品工厂. 我们可以任意地添加具体产品, 只要它遵循我们规定好的接口就行. 
    - 问题也显而易见, 如果要修改接口, 那么所有的具体产品工厂的接口都要修改. 
    - 课本中, 给的产品例子是各个厂商的空调, 电视等. 这些都是现实中存在的. 而日本老哥例子中, 抽象产品是链接, 数据, 页面. 所以, 不要被现实世界困扰, 做好自己的抽象就行. 
- 上面说的是错的, 完完全全的错误的. 下面我会仔细地描述一下. 
    - 从结构上来看, `factory`中, 全部是抽象的. 顶级抽象是`Item`, 接下来, 具体的抽象产品(`Page`, `Link`, `Data`)这些东西, 才是真正的对外接口. 但是不同的是, 这些抽象产品, 不是完全抽象, 除了抽象方法外, 还有内部的具体实现. 这也就是跟书中不同的地方: 抽象产品的不完全抽象. 
    - 这样会存在什么问题呢? 如果采用顶级抽象`Item`, 我们不论如何实现, 都只能使用那固定的一个接口. 而如果采用产品抽象, `Page`等, 则可以使用固定接口, 又可以使用`Page`特有的方法. 
    - 如果按照以前思想, 我觉得`Page`是抽象产品, 那么其所有的方法都得是抽象的. 这么来看完全不一定. 假如说, `Page`等, 是完全抽象产品, 没有自己实现, 那么其具体产品, 需要自己实现. 如果产品差异性很大, 这样无可厚非. 如果产品有一定的相似性, 在抽象层`Page`内部实现共用的方法, 也不是不可以. 
    - 之前, 我似乎也问过`gpt`这个问题, 一个产品一个类, 真的有必要吗? 这么来看的话, 其实多个产品的共性特征, 可以在抽象层统一实现, 然后呢, 针对不同产品的不同特征, 再继承抽象类, 单独分析即可. 
    - 所以说, 对外接口, 一定是`factory`, 而我们写的其它的具体工厂, 比如`table_factory`, 则是`factory`的实现, 我们并不关心. 以后有其他具体工厂, 我们完全可以再开辟一个文件夹, 写就行了. 
    - 书中呢, 没有很好地将`uml`各个模块分离开来, 而只是单独地将它们放在一个图中, 代码也是, 只在一个文件中, 十分混乱. 而根据这个日本老哥的项目呢, 可以很清晰地将各个`uml`模块划分出来, 而且十分明确. 
    - 如果是我的话, 按照书中的内容, 会选择将抽象工厂放到一个文件夹中, 抽象产品再分别放到对应的文件夹中. 具体工厂和具体产品呢, 可能又会弄文件夹, 但是总会感觉十分混乱, 调用的时候, 也不好调用. 日本老哥是将抽象层, 放在一块, 实现层再放在一块, 实现层的实现需要随时关注抽象层提供的接口. 而客户端不必关心实现层, 只调用抽象层的接口就行了. 当然, 实例化的时候肯定还是要进行产品选择的操作的. 
    - 另外, 抽象工厂模式的问题也要十分清楚, 随着具体实现越来越多, 底层接口会越来越难改变. 添加抽象产品也几乎是无法添加的. 
- 上面说完了, 现在看结构的话, 好清晰啊. 抽象层可以放在一块, 实现层放在一块, 完美啊!












