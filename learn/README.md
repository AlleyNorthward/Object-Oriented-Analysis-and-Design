&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2025-12-19 23:00:58  

# 简介

这里主要记录一些设计思想吧, 比如, 有时候可能会有奇思妙想, 记录在这里, 方便后续追录学习. 算了, 各种关系等等的, 也都记录一下吧, 感觉还是不错的. 

- [灵思妙想](#灵思妙想)
    - [单一对象分析](#单一对象分析)
    - [Group](#Group)
- [类间关系](#类间关系)
    - [关联关系](#关联关系)
        - [聚合关系](#聚合关系)
        - [组合关系](#组合关系)
    - [依赖关系](#依赖关系)
    - [泛化关系](#泛化关系)
    - [实现关系](#实现关系)
    - [举例说明](#举例说明)
    - [关系总结](#关系总结)
- [面向对象设计原则](#面型对象设计原则)
    - [开闭原则](#开闭原则)
    - [依赖倒置原则](#依赖倒置原则)
    - [里氏代换原则](#里氏代换原则)
    - [合成-聚合复用原则](#合成聚合复用原则)
    - [单一职责原则](#单一职责原则)
    - [迪米特法则](#迪米特法则)
    - [接口隔离原则](#接口隔离原则)

## 灵思妙想

### 单一对象分析
- 什么是对象? 我是一个对象吗? 从面向对象的角度来看, 是的. 
- 可是, 对于人类而言, 有数不胜数的对象. 我们如果分析多个对象, 会看它们有很多不同. 
- 所以, 我们在抽象建模的时候, 多对象分析, 很容易造成混乱. 而单一对象分析, 提取特征, 或许能够简便一些. 

### Group

- `Group`是什么意思呢? 就是组的意思. 这其实是在`Ai`, 矢量图那里学到的思想, 但是最初是在`manim`中见到的. 
- 我觉得用在建模这里也很不错. 
- 比如, 上面说的人, 往下细分的话, 会有各种器官, 器官再细分的话, 会有各种组织, 再往下细分, 还会有细胞等等.
- 对于我们人而言, 可以说是由各种器官等等组成的一个组. 但是, 这个组内部的各种东西, 我们都可以抽象起来, 不对外可见, 分析的时候, 只分析这个人(对象)就可以了. 
- 这其实是抽象的第一层. 
- 接下来, 如果我们分析的对象, 从一个人, 变成一个班级, 一个乐队, 一个运动会的参赛人员, 那这样, 一组人类的对象, 可以组成上面说的一个班级对象, 一个乐队对象, 一个运动会参赛人员对象. 
- 这样, 我们评价一个班级, 其实也就给这个班级内部的对象进行了整体评价. 我们不需要对这个班级内部的每个对象进行评价(这其实是班级内部的事, 我们现在从学校视角来看的), 只需要对班级评价即可. 而这个班级, 就是一个组. 
- 同理, 同一年级中, 也是一个组, 是由各个班级组成的一个组. 同样, 年级也是一个组, 各个年级组成的组, 形成了一个学校. 等等等等. 
- 所以, 我们分析的时候, 最好找到我们分析的最小对象(当然不是细胞什么的, 而是能解决当下实际问题的最小对象), 然后呢, 将该对象抽象完成后形成的类, 视为一个整体(组), 再进行后续分析. 
- 抽象工厂模式中, 我觉得所谓的上层客户端, 其实就是使用这个组的上层. 所以说, 如果只是单一层级, 由`A->B`的关系的话, `B`是`A`的客户端, 我们或许可以使用一次抽象工厂(注意, 我这里说的是或许可以使用, 但肯定视情况而定的), 但如果是下列情形, `A->B->C->D`, 我们甚至可以使用多次抽象工厂模式. 
- 为什么呢? 比如, `B`是`A`的客户端, 我可以调用. 接下来, 我将`AB`视为一个组, 对我而言, 其实`AB`就是一个整体了, 我不关系其内部实现, 如果将`AB`视为`E`的话, 那么问题其实就变成了`E->C->D`. 等等, 最后其实就变成了单一层级`F->D`了. 
- 当然, 我这里只是举了一个例子. 实际情况肯定更复杂. 我这里呢, 只是想提供一个组的思想, 用来描述不同类别之间的关系与关联. 

## 类间关系
- 其实一开始写的时候呢, 是在没搞清楚的情况下写的, 这里呢, 我将它们全都删掉了, 重新用最简单, 最干净的方式来捋顺它们之间的关系.
### 关联关系
- 对于关联关系, 其实非常简单, 就是某对象是该对象的属性. 但是呢, 这种属性, 根据实际需求, 又会存在各种各样的关系. 注意, 我这里说的属性, 就是`C++`中的成员变量.
- 我们先来看关联关系, 这个关系, 跟依赖关系其实很像, 不同就是关联关系是一直关联, 对象的内部"记住"了对方. 而依赖关系就是**临时用一下**, 不用就没有关系. 
- 比如, 一个手机, 我们既可以认为, 它跟某个人具有关联关系(我拥有一部手机), 也可以认为它跟某个人具有依赖关系(我使用一部手机, 但这部手机不一定属于我). 同样, 像自行车, 汽车等等, 都可以与人建立双向联系. 关键的不同, 就是根据实际需求, 来确定最终的实际关系. 
- 需要强调的是, 依赖是**我用过你**, 关联是**我有你**, 这肯定是不同的. 
#### 聚合关系
- 聚合关系在调用上, 跟关联关系一模一样. 都是成员变量, 都是初始化时传参绑定. 那么如何区分二者呢? 
- 注意这里, 聚合关系, 其实是关联关系的一类. 关联是"知道彼此", 而聚合是**整体-部分关系**(若拥有), 也就是说, **聚合是一种特殊的关联**
- 另外, 我们这是在建模, 讲述的是语义关系, 但在实现时, 是用高级语言实现的. 语义不等于语法. 
- 所以, 从语法上来看, 二者在调用上没有区别, 但是在实际语义中, 确实是不同的. 关键是看生命周期, 若分开, 彼此都能单独存在, 就是关联关系. 若主对象无法独立存在, 而次对象可以存在, 那么就是聚合关系. 
- 所以, 在建模时, 需要区分这种情况, 并且明白这之间的不同. 
#### 组合关系
- 组合关系, 就比较好区分了. 首先有一个成员变量. 但是该成员变量不是指针, 而是实际存在的实体. 初始化时不用传参, 两个对象之间, 生命周期完全同步. 
### 依赖关系
- 依赖关系呢, 在关联关系中说的比较详细了, 这里不再做重复了. 
### 泛化关系
- 这个不做具体细分, 我们就当做抽象类的具体实现就好. 
### 实现关系
- 在`c++`中呢, 泛化关系就等于实现关系, 这里也不再进行过多的叙述了. 
### 举例说明
- 人和手机, 可能是依赖关系, 可能是关联关系, 关键要看情境, 这个手机是否一直跟人绑定. 
- 汽车和引擎, 是聚合关系, 但也可以是组合关系, 仍要看情景. 
- 人和脸, 典型的组合关系. 
- 图书馆和图书, 聚合关系, 图书可以被借阅走.
- 公司和员工, 关联关系, 员工可以单独离职. 
- 订单和订单项, 通常是组合关系.
- 教师和学生, 关联关系(双向关联).
- 这么来看, 其实就很简单, 先看生命周期, 一致的话, 大概率是组合关系. 再看主对象和次对象能不能单独分开, 能的话, 就是关联关系, 不能就是聚合关系. 如果是关联关系, 则要再分析是不是依赖关系, 到此就结束了. 
### 关系总结
- 上面的公司和员工呢, `ai`给的是关联关系. 但是呢, 按照我上面的总结来看, 二者似乎是聚合关系:生命周期不同, 公司没了员工, 不能存在, 是聚合关系. 这么想是否对呢? 
- 我觉得还是搞混了. 从建模角度分析, 不要总考虑它是否能运行. 照这么来看, 似乎就没有关联关系了...聚合关系就像是一个组件, 从建模角度来看, 是必要组成成分, 从运行角度来看, 也是必不可少的一部分. 关键是建模角度跟运行角度完全不同. 建模考虑的是是否合理, 比如汽车, 建模角度来看, 我不关心它是否能跑, 我只关心它是否合理. 公司, 供应商, 员工, 其实都是单独的一部分, 真实世界中, 少了谁都无法运转. 但是建模角度来看, 我只分析公司, 只分析供应商, 只分析员工. 它们只要能做好自己的本职工作就好了. 公司, 提供良好的工作环境, 舒适的氛围, 供应商, 提供生产某产品的环境, 而员工, 可以是公司员工, 可以是供应商员工, 他们具有联系, 生产, 规划等能力, 公司, 供应商内部有了这些员工可以彼此通信交流等等, 这样运行角度来看, 完美运行. 
- 所以, 我是想说什么呢, 建模思维是很重要的. 不要总想着现实世界怎么样, 我们需要总建模角度分析. 
- 还有就是, 高级语言实现层面, 关联和聚合, 是类似的, 成员变量, 初始化时传入对象. 
- 最后总结下来呢, 还是上面说的那样, 第一, 看生命周期, 一致大概率组合. 再看主对象和次对象, 首先是分开, 能是关联, 不能且有组装的感觉, 可能是聚合. 关联关系也需要分析是否是聚合关系. 

## 面向对象设计原则
- 具体概念呢, 书中都有, 我这里简单说说应用情形. 具体的应用情况, 会在对应目录中详细分析的. 
### 开闭原则
- 抽象基类, 接口类, 统一接口. 多态. 
- 相当于建房子, 我期望后续房子能够加房间, 加阳台, 而不是每加一个房间就拆承重墙.
- 这是一个目标. 
### 依赖倒置原则
- 也是抽象基类. 但不同的是, 能够灵活自动选择. 
- 还是建房子, 承重结构不能依赖家具, 水电管道不能写死某个品牌. 
- 这是结构规则.
- 举一个最简单的例子. 我写了一个按键绑定函数, 我不期望内部写死逻辑, 每次修改绑定还要修改这个函数. 所以, 我传入一个函数指针, 每次调用的时候, 框架不用修改, 只需要写好函数指针指向的函数就好, 然后将这个指针传入即可. 
- 依赖倒置是类似的. 选择哪个支付系统, 我只需要传入对应支付系统的对象即可, 而不是在类内部写死, 或者用`if-else`, 难以拓展. 
### 里氏代换原则
- 这个在`manim`中, 理解了好久, 最后终于明确了. 这里不再多说了. 
### 合成聚合复用原则
- 少用, 甚至不用继承. 
### 单一职责原则
- 就跟它名字一样. 
### 迪米特法则
- 
### 接口隔离原则







